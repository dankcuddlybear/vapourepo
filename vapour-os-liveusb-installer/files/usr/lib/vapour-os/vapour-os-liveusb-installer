#!/bin/bash
DISTRO_ID="vapour-os"
DISTRO_NAME="Vapour OS"
Print() {
	echo "[INSTALLER] $1"
}
Error() {
	echo "[INSTALLER: ERROR] $1"
	exit 1
}
[ $(whoami) != "root" ] && Error "You must run this script with root priviliges."
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
E2OPTIONS="ea_inode,encrypt,inline_data,large_dir,project,quota,uninit_bg,verity"
ARCH="$(uname -m)"
unset PARTITION_NOT_FOUND
timedatectl set-ntp true
sync
## 1) Prepare and mount filesystems
ValidatePartition() { # Checks that each partition exists, and resolves links
	if [ ! -z "$1" ]; then
		if [ -b "$1" ]; then echo "$(readlink -f "$1")"; else PARTITION_NOT_FOUND=1; fi
	fi
}
[ -z "$ROOT_DEV" ] && Error "No root partition specified. Please set variable ROOT_DEV to the root partition."
[ -z "$BOOT_DEV" ] && Error "No EFI system partition specified. Please set variable BOOT_DEV to the ESP."
ROOT_DEV="$(ValidatePartition "$ROOT_DEV")"; [ ! -z $PARTITION_NOT_FOUND ] && Error "Root partition $ROOT_DEV does not exist!"
BOOT_DEV="$(ValidatePartition "$BOOT_DEV")"; [ ! -z $PARTITION_NOT_FOUND ] && Error "EFI system partition $BOOT_DEV does not exist!"
BOOT_DEV="$(readlink -f "$BOOT_DEV")"
if [ "${BOOT_DEV:5:2}" == "hd" ] || [ "${BOOT_DEV:5:2}" == "sd" ] || [ "${BOOT_DEV:5:2}" == "vd" ]; then
	ESPDISK="${BOOT_DEV:0:8}"
	ESPPART="${BOOT_DEV:8:3}"
elif [ "${BOOT_DEV:5:4}" == "nvme" ]; then
	ESPDISK="${BOOT_DEV:0:12}"
	ESPPART="${BOOT_DEV:13:3}"
elif [ "${BOOT_DEV:5:6}" == "mmcblk" ]; then
	ESPDISK="${BOOT_DEV:0:12}"
	ESPPART="${BOOT_DEV:13:3}"
else Error "Error detecting /boot partition!"; fi
HOME_DEV="$(ValidatePartition "$HOME_DEV")"; [ ! -z $PARTITION_NOT_FOUND ] && Error "Home partition $HOME_DEV does not exist!"
MEDIA_DEV="$(ValidatePartition "$MEDIA_DEV")"; [ ! -z $PARTITION_NOT_FOUND ] && Error "Media partition $MEDIA_DEV does not exist!"
PUBLIC_DEV="$(ValidatePartition "$PUBLIC_DEV")"; [ ! -z $PARTITION_NOT_FOUND ] && Error "Public partition $PUBLIC_DEV does not exist!"
SWAP_DEV="$(ValidatePartition "$SWAP_DEV")"; [ ! -z $PARTITION_NOT_FOUND ] && Error "Swap partition $SWAP_DEV does not exist!"
# Unmount any mounted filesystems
if [ ! -z "$SWAP_DEV" ] && [ ! -z "$(cat /proc/swaps | grep "$SWAP_DEV")" ]; then # Unmount mounted swap partition
	sync
	swapoff "$SWAP_DEV" && Print "Unmounted $SWAP_DEV" || Error "Failed to unmount $SWAP_DEV"
fi
for MOUNT in $(findmnt -lno TARGET -d backward | grep "/mnt"); do
	sync
	umount -fl "$MOUNT" && Print "Unmounted $MOUNT" || Error "Failed to unmount $MOUNT"
done

# Format and tune root and boot partition, if marked for formatting
[ ! -z $FORMAT_ROOT ] && [ $FORMAT_ROOT == 1 ] && Print "Formatting root partition $ROOT_DEV $LABEL_ROOT" && mkfs.ext4 -FL "$LABEL_ROOT" -O $E2OPTIONS "$ROOT_DEV"
tune2fs -O $E2OPTIONS -c 1 -o acl,discard,user_xattr "$ROOT_DEV"
debugfs -w -R "set_super_value mount_opts auto_da_alloc,i_version,journal_checksum,lazytime" "$ROOT_DEV"
[ ! -z $FORMAT_BOOT ] && [ $FORMAT_BOOT == 1 ] && Print "Formatting boot partition $BOOT_DEV $LABEL_BOOT" && mkfs.fat -F 32 -n "$LABEL_BOOT" "$BOOT_DEV"
# Set boot flag on /boot partition
parted "$ESPDISK" set "$ESPPART" boot on 1> /dev/null
Print "Set boot flag on $BOOT_DEV."
# Format and tune other partitions, if marked for formatting
if [ ! -z "$HOME_DEV" ]; then
	[ ! -z $FORMAT_HOME ] && [ $FORMAT_HOME == 1 ] &&  Print "Formatting home partition $HOME_DEV $LABEL_HOME" && mkfs.ext4 -FL "$LABEL_HOME" -O $E2OPTIONS "$HOME_DEV"
	tune2fs -O $E2OPTIONS -c 1 -o acl,discard,user_xattr "$HOME_DEV"
	debugfs -w -R "set_super_value mount_opts auto_da_alloc,i_version,journal_checksum,lazytime,nodev,nosuid" "$HOME_DEV"
fi
if [ ! -z "$MEDIA_DEV" ]; then
	[ ! -z $FORMAT_MEDIA ] && [ $FORMAT_MEDIA == 1 ] && Print "Formatting media partition $MEDIA_DEV $LABEL_MEDIA" && mkfs.ext4 -FL "$LABEL_MEDIA" -O $E2OPTIONS "$MEDIA_DEV"
	tune2fs -O $E2OPTIONS -c 1 -o acl,discard,user_xattr "$MEDIA_DEV"
	debugfs -w -R "set_super_value mount_opts auto_da_alloc,i_version,journal_checksum,noatime,nodev,nosuid" "$MEDIA_DEV"
fi
if [ ! -z "$PUBLIC_DEV" ]; then
	[ ! -z $FORMAT_PUBLIC ] && [ $FORMAT_PUBLIC == 1 ] && Print "Formatting /public partition $PUBLIC_DEV $LABEL_LABEL" && mkfs.ext4 -FL "$LABEL_PUBLIC" -O $E2OPTIONS "$PUBLIC_DEV"
	tune2fs -O $E2OPTIONS -c 1 -o acl,discard,user_xattr "$PUBLIC_DEV"
	debugfs -w -R "set_super_value mount_opts auto_da_alloc,i_version,journal_checksum,noatime,nodev,nosuid" "$PUBLIC_DEV"
fi
[ ! -z "$SWAP_DEV" ] && Print "Formatting swap partition $SWAP_DEV $LABEL_SWAP" && mkswap -L "$LABEL_SWAP" "$SWAP_DEV"
# Mount and clear root filesystem
mount "$ROOT_DEV" /mnt
if [ "$FORMAT_ROOT" != 1 ]; then
	Print "Deleting old system files in root partition..."
	rm -rf /mnt/bin /mnt/dev /mnt/etc /mnt/lib /mnt/lib64 /mnt/mnt /mnt/opt /mnt/proc /mnt/root /mnt/run /mnt/sbin /mnt/sys /mnt/tmp /mnt/usr /mnt/var
fi
# Create mount points
mkdir "/mnt/boot" &> /dev/null
mkdir "/mnt/public" &> /dev/null; chmod 777 "/mnt/public"; chmod +t "/mnt/public"
[ ! -z "$HOME_DEV" ] && mkdir /mnt/home &> /dev/null
[ ! -z "$MEDIA_DEV" ] && mkdir /mnt/media &> /dev/null && chmod 777 /mnt/media && chmod +t /mnt/media
Print "Mount points created."
# Mount and clear other filesystems
mount "$BOOT_DEV" /mnt/boot
if [ $FORMAT_BOOT != 1 ]; then
	Print "Deleting old system files in boot partition..."
	rm -rf /mnt/boot/*.img /mnt/boot/vmlinu* /mnt/boot/EFI/systemd /mnt/boot/limine /mnt/boot/loader
fi
[ ! -z "$HOME_DEV" ] && mount "$HOME_DEV" /mnt/home
[ ! -z "$MEDIA_DEV" ] && mount "$MEDIA_DEV" /mnt/media
[ ! -z "$PUBLIC_DEV" ] && mount "$PUBLIC_DEV" /mnt/public
sync

## 2) Auto-detect required packages
PACKAGES="$VERSION_TO_INSTALL $KERNELS $EXTRA_SOFTWARE limine"
MANUFACTURER="$(dmidecode -s system-manufacturer)"
MODEL="$(HP Pavilion Gaming Laptop 17-cd1xxx)"
CHASSIS="$(dmidecode -s chassis-type)"
CPU_MODEL="$(dmidecode -s processor-version)"
CPU_MANUFACTURER="$(dmidecode -s processor-manufacturer)"
# Microcode
[ "$CPU_MANUFACTURER" == "AMD" ] && PACKAGES="$PACKAGES amd-ucode"
[ "$CPU_MANUFACTURER" == "Intel(R) Corporation" ] && PACKAGES="$PACKAGES intel-ucode"
# Detect laptop hardware
if [ ! -z "$CHASSIS" ] && ([ "$CHASSIS" == "Laptop" ] || [ "$CHASSIS" == "Notebook" ] || \
[ "$CHASSIS" == "Convertible" ] || [ "$CHASSIS" == "Detachable" ] || [ "$CHASSIS" == "Tablet" ] || \
[ "$CHASSIS" == "Hand Held" ] || [ "$CHASSIS" == "Portable" ]); then
	if [ ! -z "$CHASSIS" ] && ([ "$CHASSIS" == "Laptop" ] || [ "$CHASSIS" == "Notebook" ] || \
	[ "$CHASSIS" == "Convertible" ] || [ "$CHASSIS" == "Detachable" ] || [ "$CHASSIS" == "Tablet" ]); then
		PORTABLE="yes"
		if [ -f /dev/freefall ]; then
			echo "Found freefall sensor"
			PACKAGES="$PACKAGES hdapsd"
		fi
	fi
else PORTABLE="no"; fi
# Print info
Print "Manufacturer: $MANUFACTURER"
Print "       Model: $MODEL"
Print "        Type: $CHASSIS"
Print "    Portable: $PORTABLE"
Print "   Processor: $CPU_MODEL"

## 3) Install packages
for KERNEL in $KERNELS; do PACKAGES="$PACKAGES $KERNEL $KERNEL-headers"; done
if [ "$VERSION_TO_INSTALL" != "vapour-os" ]; then
	PACKAGES="$PACKAGES lib32-pipewire-jack pipewire-alsa pipewire-jack pipewire-pulse wireplumber"
	case "$VERSION_TO_INSTALL" in
		vapour-os-gnome) PACKAGES="$PACKAGES xdg-desktop-portal-gnome";;
		vapour-os-kde) PACKAGES="$PACKAGES xdg-desktop-portal-kde";;
		vapour-os-xfce) PACKAGES="$PACKAGES xdg-desktop-portal-gtk";;
	esac
fi
pacstrap /mnt $PACKAGES || exit 1
genfstab -U /mnt >> /mnt/etc/fstab
echo "proc /proc proc nosuid,nodev,noexec,hidepid=2,gid=proc 0 0" >> /etc/fstab
mkdir -p "/mnt/etc/$DISTRO_ID"
cp "$SCRIPT_DIR/chroot-setup" "/mnt/etc/$DISTRO_ID/chroot-setup"
echo "$EXTRA_SOFTWARE" > "/mnt/etc/$DISTRO_ID/extra-software"
echo "$KERNELS" > "/mnt/etc/$DISTRO_ID/kernels"
echo "$VERSION_TO_INSTALL" > "/mnt/etc/$DISTRO_ID/version-to-install"

# Detect manufacturer and model info, and enable fixes accordingly
case "$MANUFACTURER" in
	"HP")
		[ "$PORTABLE" == "yes" ] && echo "systemctl enable hp-lid-fix" >> "/mnt/etc/$DISTRO_ID/chroot-setup"
		;;
esac

sync
arch-chroot /mnt "/etc/$DISTRO_ID/chroot-setup" || exit 1
rm -rf "/mnt/etc/$DISTRO_ID/chroot-setup" "/mnt/etc/$DISTRO_ID/extra-software" "/mnt/etc/$DISTRO_ID/kernels" "/mnt/etc/$DISTRO_ID/version-to-install"
sync
